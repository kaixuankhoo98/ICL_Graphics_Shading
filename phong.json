{"camera":{"position":[-0.3437580876692523,0,37.99801481616281],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace;\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace;\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\n// ========= Added variables ============\nvarying vec3 vertexPos;\nvarying vec3 vertexNorm;\n\n//main program for each vertex\nvoid main() {\n  vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n  \n  vertexPos = (mMatrix * vec4(vertex_worldSpace,1.0)).xyz;\n  vertexNorm = (mMatrix * vec4(normal_worldSpace, 0.0)).xyz;\n  \n  gl_Position = pMatrix * vertex_camSpace;\n}"},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\n\n// ========= Added variables ==========\n#define PI 3.1415926589793238462643383\nvarying vec3 vertexPos; // from vertex shader\nvarying vec3 vertexNorm; // from vertex shader\nuniform vec3 cameraPos;\n\n// from the spec\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform vec4 specular;\n// constants, defined as uniform to be changed in uniforms tab\nuniform float k_d; // diffuse coefficient\nuniform float k_s; // specular coefficient\nuniform float s; // heuristic constant\nuniform float shininess;\nuniform float phi;\n\n//main program for each fragment = pixel candidate\nvoid main() {\n  vec3 norm = normalize(vertexNorm);\n\n  vec3 lightDirection = cameraPos - vertexPos;\n  vec3 lightDir_norm = normalize(lightDirection);\n  float d = length(lightDirection);\n\n  // ambient\n  vec4 ambient_component = ambient;\n  // diffuse\n  float diff_val = k_d * max(dot(norm, lightDir_norm), 0.0);\n  vec4 diffuse_component = diffuse * diff_val;\n  // specular\n  vec3 reflect = reflect(-lightDir_norm, norm); // reflect about the normal\n  vec3 viewDir = cameraPos - vertexPos;\n  float spec_val = k_s * pow((max(dot(normalize(viewDir), reflect), 0.0)), shininess);\n  vec4 specular_component = specular * spec_val;\n\n  float d_a = phi / (4.0 * PI * (d + s));\n\n  // assign\n  gl_FragColor = (ambient_component + diffuse_component + specular_component) * d_a;\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"cameraPos":{"attachment":"Camera Position"},"ambient":{"value":[0.5,0,0,1]},"diffuse":{"value":[1,0,0,1]},"specular":{"value":[1,1,1,1]},"k_d":{"value":[1]},"k_s":{"value":[0.05]},"s":{"value":[0.5]},"shininess":{"value":[10]},"phi":{"value":[5000]}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec3 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertex_worldSpace, 1.0);\n  varyingTextureCoordinate = textureCoordinate_input;\n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each fragment of the render quad\nvoid main() {\n  gl_FragColor = texture2D(textureRendered, varyingTextureCoordinate.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}