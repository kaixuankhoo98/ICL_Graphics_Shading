{"camera":{"position":[-0.35401776743182256,7.646330832853712,37.073013044732335],"target":[0,0,0],"nearClipping":0.1,"farClipping":1000,"projection":"Perspective","perspectiveFov":45,"orthographicFov":30},"model":{"mesh":"teapot","position":[0,-8,0],"rotationAxis":[1,0,0],"rotationAngle":-90,"scale":[1,1,1],"depthTest":"LESS","faceCulling":"","frontFace":"CCW"},"passes":{"Model":{"base":{"shaders":{"vertex":{"source":"//vertex position in world coordinates\nattribute vec3 vertex_worldSpace;\n//surface normal at the vertex in world coordinates\nattribute vec3 normal_worldSpace;\n//texture coordinates at that vertex\nattribute vec2 textureCoordinate_input;\n\n//model Matrix (Identity in our case)\nuniform mat4 mMatrix;\n//view Matrix\nuniform mat4 vMatrix;\n//projection Matrix\nuniform mat4 pMatrix;\n\n// ========= Added variables ============\n#define PI 3.1415926589793238462643383\nvarying vec4 v_color; // writes to fragment shader\n// from the spec\nuniform vec3 cameraPos;\nuniform vec4 ambient;\nuniform vec4 diffuse;\nuniform vec4 specular;\n// constants, defined as uniform to be changed in uniforms tab\nuniform float k_d; // diffuse coefficient\nuniform float k_s; // specular coefficient\nuniform float s; // heuristic constant\nuniform float shininess;\nuniform float phi;\n\n//main program for each vertex\nvoid main() {\n  vec4 vertex_camSpace = vMatrix * mMatrix * vec4(vertex_worldSpace, 1.0);\n  \n  // this took me a while lol\n  vec3 vertex_pos = vec3(mMatrix * vec4(vertex_worldSpace, 1.0));\n  // normal is a direction vector starting at origin\n  vec3 normal = normalize(vec3(mMatrix * vec4(normal_worldSpace, 0.0)));\n\n  vec3 lightPosition = cameraPos; // headlight\n  vec3 viewDirection = lightPosition - vertex_pos;\n  vec3 lightDirection = lightPosition - vertex_pos;\n  vec3 lightDir_normal = normalize(lightDirection);\n  float d = length(lightDirection);\n\n  // ambient component\n  vec4 ambient_component = ambient;\n  // diffuse component\n  float diff_val = (k_d * max(dot(normal, lightDir_normal), 0.0));\n  vec4 diffuse_component = diff_val * diffuse;\n  // specular component\n  vec3 refl = reflect(-lightDir_normal, normal);\n  float spec_val = k_s * pow((max(dot(normalize(viewDirection), refl), 0.0)), shininess);\n  vec4 specular_component = specular * spec_val;\n\n  // distance attenuation\n  float d_a = phi / (4.0 * PI * (d * s));\n\n  v_color = (ambient_component + diffuse_component + specular_component) * d_a;\n  gl_Position = pMatrix * vertex_camSpace;\n}"},"fragment":{"source":"//for better performance less precision\nprecision mediump float;\n\nvarying vec4 v_color; // reads from vertex shader\n\n//main program for each fragment = pixel candidate\nvoid main() {\n  gl_FragColor = v_color;\n}"}},"uniforms":{"value":{"mMatrix":{"attachment":"Model Matrix"},"vMatrix":{"attachment":"View Matrix"},"pMatrix":{"attachment":"Projection Matrix"},"cameraPos":{"attachment":"Camera Position"},"ambient":{"value":[0.5,0,0,1]},"diffuse":{"value":[1,0,0,1]},"specular":{"value":[1,1,1,1]},"k_d":{"value":[1]},"k_s":{"value":[0.05]},"s":{"value":[0.5]},"shininess":{"value":[10]},"phi":{"value":[5000]}}}}},"Quad":{"R2T":{"shaders":{"vertex":{"source":"//vertex coordinates in world space for the render quad\nattribute vec3 vertex_worldSpace;\n//texture coordinate for this vertex and the render quad\nattribute vec2 textureCoordinate_input;\n\n//texture coordinate needs to be passed on to the R2T fragment shader\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each vertex of the render quad\nvoid main() {\n  gl_Position = vec4(vertex_worldSpace, 1.0);\n  varyingTextureCoordinate = textureCoordinate_input;\n}"},"fragment":{"source":"precision mediump float;\n\n//a texture sampling unit, which is bound to the render quad texture buffer\nuniform sampler2D textureRendered;\n\n//texture coordinates coming from the vertex shader, interpolated through the rasterizer\nvarying vec2 varyingTextureCoordinate;\n\n//main program for each fragment of the render quad\nvoid main() {\n  gl_FragColor = texture2D(textureRendered, varyingTextureCoordinate.st);\n}"}},"uniforms":{"value":{"textureRendered":{"attachment":"Model/base Pass color"}}}}}},"output":{"image":"Quad/R2T Pass color"}}